<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" debug="true" hostspecific="true" #>
<#@ output extension=".xsd" #>
<#@ assembly name="System.Configuration.dll" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ ConfigurationSectionDesigner processor="ConfigurationSectionDesignerDirectiveProcessor" requires="fileName='$inputFileName$'" #>
<?xml version="1.0"?>
<!--
<auto-generated>
    This code was generated by a tool.

     Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
-->
<xs:schema xmlns:tns="<#= this.ConfigurationSectionModel.XmlSchemaNamespace #>" elementFormDefault="qualified" targetNamespace="<#= this.ConfigurationSectionModel.XmlSchemaNamespace #>" xmlns:xs="http://www.w3.org/2001/XMLSchema">
<#

// Write top-level elements only
foreach (BaseConfigurationType element in this.ConfigurationSectionModel.ConfigurationElements)
{
    if (element.InheritanceModifier == InheritanceModifiers.Abstract) continue;
    
	IConfigSectionElement configSectionElement = element as IConfigSectionElement;
	if (configSectionElement != null)
	{
		ConfigurationSection configSection = configSectionElement as ConfigurationSection;
		ConfigurationSectionGroup configSectionGroup = configSectionElement as ConfigurationSectionGroup;
		
		if (configSection != null)
		{
			// Are we a top-level element?
			if (configSection.ReferringConfigurationSectionGroup == null)
			{
#>
	<xs:element name="<#= configSection.XmlSectionName #>" type="tns:<#= configSection.FullName #>CT" />
<#
			}	
		}
		else if (configSectionGroup != null)
		{
			// Are we a top-level element?
			if (configSectionGroup.ReferringConfigurationSectionGroup == null)
			{
#>
	<xs:element name="<#= configSectionGroup.Name #>" type="tns:<#= configSectionGroup.FullName #>CT" />
<#
			}
		}
	}
}


foreach (BaseConfigurationType type in this.ConfigurationSectionModel.ConfigurationElements)
{
	ConfigurationElement element = type as ConfigurationElement;
	IConfigSectionElement configSectionElement = type as IConfigSectionElement;
	
	if (configSectionElement != null)
	{
		ConfigurationSectionGroup configSectionGroup = configSectionElement as ConfigurationSectionGroup;
		
		if (configSectionGroup != null)
		{
#>
	<xs:complexType name="<#= configSectionGroup.FullName #>CT">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
<#
			if( configSectionGroup.ConfigurationSectionGroupProperties.Count > 0 )
			{
				foreach( ConfigurationSectionGroupProperty configurationSectionGroupProperty in configSectionGroup.ConfigurationSectionGroupProperties )
				{
					ConfigurationSectionGroup containedConfigurationSectionGroup = configurationSectionGroupProperty.ContainedConfigurationSectionGroup;
#>
			<xs:element minOccurs="0" maxOccurs="1" name="<#= containedConfigurationSectionGroup.Name #>" type="tns:<#= containedConfigurationSectionGroup.FullName #>CT" />
<#
				}
			}
			if( configSectionGroup.ConfigurationSectionProperties.Count > 0 )
			{
				foreach( ConfigurationSectionProperty configurationSectionProperty in configSectionGroup.ConfigurationSectionProperties )
				{
					ConfigurationSection containedConfigurationSection = configurationSectionProperty.ContainedConfigurationSection;
#>
			<xs:element minOccurs="0" maxOccurs="1" name="<#= containedConfigurationSection.XmlSectionName #>" type="tns:<#= containedConfigurationSection.FullName #>CT" />
<#
				}
			}
#>
		</xs:choice>
	</xs:complexType>
<#
			continue;
		}
	}
	
	if (element == null)
		continue;
	
#>
	<xs:complexType name="<#= element.FullName #>CT">
<#
	if (element.AllElementProperties.Count > 0 || element is ConfigurationElementCollection || element.HasCustomChildElements)
	{
#>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
<#
		foreach (ElementProperty elementProperty in element.AllElementProperties)
		{
			string minOccurs = (elementProperty.IsRequired ? "1" : "0");
			
			if (string.IsNullOrEmpty(elementProperty.XmlName) && elementProperty.IsDefaultCollection)
			{
				// This is a default collection without a name. Must use the collection type instead of collection itself
				ConfigurationElementCollection collectionElement = (ConfigurationElementCollection)elementProperty.Type;
				GenerateCollectionElement(collectionElement);
			}
			else
			{
#>
			<xs:element minOccurs="<#= minOccurs #>" name="<#= elementProperty.XmlName #>" type="tns:<#= elementProperty.TypeName #>CT">
				<xs:annotation>
					<xs:documentation><#= elementProperty.DocumentationText #></xs:documentation>
				</xs:annotation>
			</xs:element>
<#
			}
		} // End loop over element properties.
		
		if (element is ConfigurationElementCollection)
		{
			ConfigurationElementCollection collectionElement = (ConfigurationElementCollection)element;
			GenerateCollectionElement(collectionElement);
		} // End collection.

		if (element.HasCustomChildElements)
		{
#>
			<xs:any minOccurs="0" processContents="lax" />
<#
		} // End element.HasCustomChildElements.
#>
		</xs:choice>
<#
	} // element.AllElementProperties.Count > 0
	
	foreach (AttributeProperty attributeProperty in element.AllAttributeProperties)
	{
		string usage = (attributeProperty.IsRequired ? "required" : "optional");
		string xsdTypeDefinition = string.Empty;
		string[] xsdRestrictions;
		string xsdTypeName = GetXsdTypeName(attributeProperty, out xsdRestrictions);
		if (!string.IsNullOrEmpty(xsdTypeName))
		{
			xsdTypeDefinition = string.Format(" type=\"{0}\"", xsdTypeName);
		}
#>
		<xs:attribute name="<#= attributeProperty.XmlName #>" use="<#= usage #>"<#= xsdTypeDefinition #>>
			<xs:annotation>
				<xs:documentation><#= attributeProperty.DocumentationText #></xs:documentation>
			</xs:annotation>
<#
		if (xsdRestrictions != null && xsdRestrictions.Length > 0)
		{
#>
			<xs:simpleType>
				<xs:restriction base="xs:string">
<#
			foreach (string xsdRestriction in xsdRestrictions)
			{
#>
					<xs:enumeration value="<#= xsdRestriction #>" />
<#
			} // End xsd restriction value
#>
				</xs:restriction>
			</xs:simpleType>
<#
		} // End xsd restrictions
#>
		</xs:attribute>
<#
	} // End loop over primitive properties.
#>
	</xs:complexType>
<#
	
	if (element is ConfigurationElementCollection)
	{
		ConfigurationElementCollection collectionElement = (ConfigurationElementCollection)element;
		
			//
			// TODO: Issue here for autogen keys. Below will have NO items, so would throw exception. 
			// We now check for null, but this may need more work to create proper XSD.
			// Learn how to create proper XSD representation of our auto-key.
			//
			string xsdTypeDefinition = string.Empty;
			string[] xsdRestrictions = null;
			string xsdTypeName = "";

			ConfigurationProperty keyProperty = collectionElement.ItemType.KeyProperties.SingleOrDefault();
			if (keyProperty != null) {
				xsdTypeName = GetXsdTypeName(keyProperty as AttributeProperty, out xsdRestrictions);
				if (!string.IsNullOrEmpty(xsdTypeName))
				{
					xsdTypeDefinition = string.Format(" type=\"{0}\"", xsdTypeName);
				}
			}
#>
	<xs:complexType name="<#= element.FullName #>RemoveCT">
	<# 
		if (keyProperty != null) { 
	#>
			<xs:attribute name="<#= keyProperty.XmlName #>" use="required"<#= xsdTypeDefinition #>>
				<xs:annotation>
					<xs:documentation><#= keyProperty.DocumentationText #></xs:documentation>
				</xs:annotation>
	<#
			if (xsdRestrictions != null && xsdRestrictions.Length > 0)
			{
	#>
				<xs:simpleType>
					<xs:restriction base="xs:string">
	<#
				foreach (string xsdRestriction in xsdRestrictions)
				{
	#>
						<xs:enumeration value="<#= xsdRestriction #>" />
	<#
				} // End xsd restriction value
	#>
					</xs:restriction>
				</xs:simpleType>
	<#
			} // End xsd restrictions
	#>
			</xs:attribute>
	<# 
		} // End keyProperty != null
	#>
	</xs:complexType>
	<xs:complexType name="<#= element.FullName #>ClearCT" />
<#
		}
	}
	
 // End loop over all configuration elements.

foreach (TypeDefinition type in this.ConfigurationSectionModel.TypeDefinitions)
{
	EnumeratedType enumType = type as EnumeratedType;
	if (enumType != null)
	{
		string enumDocumentation = enumType.Documentation;
		if (string.IsNullOrEmpty(enumDocumentation) )
		{
			enumDocumentation = enumType.Name + ".";
		}
#>
	<xs:simpleType name="<#= enumType.Name #>">
		<xs:annotation>
			<xs:documentation><#= enumDocumentation #></xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
<#
		foreach (EnumerationLiteral literal in enumType.Literals)
		{
			string literalDocumentation = literal.Documentation;
			if (string.IsNullOrEmpty(literalDocumentation) )
			{
				literalDocumentation = literal.Name + ".";
			}
#>
			<xs:enumeration value="<#= literal.Name #>">
				<xs:annotation>
					<xs:documentation><#= literalDocumentation #></xs:documentation>
				</xs:annotation>
			</xs:enumeration>
<#
		} // End EnumerationLiteral
#>
		</xs:restriction>
	</xs:simpleType>
<#
	} // End EnumeratedType
} // End TypeDefinition
#>
</xs:schema>
<#+
	private string GetXsdTypeName(AttributeProperty attribute, out string[] restrictions)
	{
		restrictions = null;
		EnumeratedType enumType = attribute.Type as EnumeratedType;
		if (enumType != null)
		{
			return "tns:" + enumType.Name;
		}
		
		string clrTypeName = attribute.TypeName;
		Type clrType = Type.GetType(clrTypeName);
		if (clrType == null)
		{
			return null;
		}
		if (clrType == typeof(System.String))
		{
			return "xs:string";
		}
		if (clrType == typeof(System.Boolean))
		{
			return "xs:boolean";
		}
		if (clrType == typeof(System.Int32))
		{
			return "xs:int";
		}
		if (clrType == typeof(System.Int64))
		{
			return "xs:long";
		}
		if (clrType == typeof(System.Single))
		{
			return "xs:float";
		}
		if (clrType == typeof(System.Double))
		{
			return "xs:double";
		}
		if (clrType == typeof(System.DateTime))
		{
			return "xs:dateTime";
		}
		if (clrType == typeof(System.TimeSpan))
		{
			return "xs:time";
		}
		if (clrType.IsEnum)
		{
			restrictions = Enum.GetNames(clrType);
			return null;
		}
		return null;
	}
	
	private void GenerateCollectionElement(ConfigurationElementCollection collectionElement)
	{
		PushIndent("\t\t\t");
		
        if( collectionElement.CollectionType == System.Configuration.ConfigurationElementCollectionType.BasicMap
            || collectionElement.CollectionType == System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate )
        {
			WriteLine(string.Format("<xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"{0}\" type=\"tns:{1}CT\">", collectionElement.XmlItemName, collectionElement.ItemType.FullName));
		}
		else
		{
			WriteLine(string.Format("<xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"{0}\" type=\"tns:{1}ClearCT\" />", collectionElement.ClearItemsName, collectionElement.FullName));
			WriteLine(string.Format("<xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"{0}\" type=\"tns:{1}RemoveCT\" />", collectionElement.RemoveItemName, collectionElement.FullName));
			WriteLine(string.Format("<xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"{0}\" type=\"tns:{1}CT\">", collectionElement.AddItemName, collectionElement.ItemType.FullName));
		}
		PushIndent("\t");
		WriteLine("<xs:annotation>");
		PushIndent("\t");
		WriteLine(string.Format("<xs:documentation>{0}</xs:documentation>", collectionElement.ItemType.DocumentationText));
		PopIndent();
		WriteLine("</xs:annotation>");
		PopIndent();
		WriteLine("</xs:element>");
		PopIndent();
	}
#>