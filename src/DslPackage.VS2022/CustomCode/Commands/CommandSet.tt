<#@ output extension=".cs" #>
<#@ import namespace = "System.Collections.Generic" #>
<#@ import namespace = "System.Collections.ObjectModel" #>
<#@ include file="CommandSetConfig.tt" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.Design;
using Microsoft.VisualStudio.Modeling;
using Microsoft.VisualStudio.Modeling.Shell;
using Microsoft.VisualStudio.Modeling.Diagrams;

namespace ConfigurationSectionDesigner
{
    /// <summary>
    /// Custom code for ConfigurationSectionDesignerCommandSet.
    /// </summary>
    internal partial class ConfigurationSectionDesignerCommandSet
    {	
		
        #region Constants

<#
const string CommandId = "CommandId";
const string CanonicalName = "CanonicalName";
const string Id = "Id";



foreach (Dictionary<string, string> element in commands)
{
		// Hack to prevent VS from failing the build with no explaination due to "var not used" warning on Id... Wasted 2 hours on this. Are you F'ing kidding me Microsoft???
		string commandId = Id;
		commandId = "";
		if (!element.TryGetValue(CommandId, out commandId))
		{
			commandId = string.Format("0x{0}", index.ToString("X"));
		}
#>
        /// <summary>
        /// cmd<#= element[CanonicalName] #> commmand identifier.
        /// </summary>
        private const int cmd<#= element[CanonicalName] #>ID = <#= commandId #>;

<#
    index++;
}
#>
        #endregion

        #region Members

<#
foreach (Dictionary<string, string> element in commands)
{
#>
        /// <summary>
        /// cmd<#= element[CanonicalName] #> unique identifier.
        /// </summary>
        private Guid cmd<#= element[CanonicalName] #>GUID = new Guid("<#= element["Id"] #>");

<#
}
#>
        #endregion

        #region Overrides

        /// <summary>
        /// Provide the menu commands that this command set handles.
        /// </summary>
        /// <returns>A list of commands.</returns>
        protected override IList<MenuCommand> GetMenuCommands()
        {
            // Execute base
            IList<MenuCommand> commands = base.GetMenuCommands();

<#
foreach (Dictionary<string, string> element in commands)
{
#>
            // Add the <#= element[CanonicalName] #> menu command
			commands.Add(
				CreateCommand(
					new EventHandler(this.OnPopUpMenuDisplayAction),
					new EventHandler(this.OnPopUpMenuClick),
					new CommandID(
						this.cmd<#= element[CanonicalName] #>GUID,
						cmd<#= element[CanonicalName] #>ID)));

<#
}
#>
            return commands;
        }

        #endregion
        
        #region Event Handlers

        /// <summary>
        /// Occurs when one of the custom menu items is being displayed.
        /// </summary>
        /// <param name="sender">Sender of this event.</param>
        /// <param name="e">Event arguments.</param>
        internal void OnPopUpMenuDisplayAction( object sender, EventArgs e )
        {
            // Control availability of the command
            MenuCommand command = sender as MenuCommand;
            
            if( command != null )
            {
				bool canCommandRun = true;
				
                // Check what command it is
<#
bool isFirstCommand = true;
foreach (Dictionary<string, string> element in commands)
{
#>
                <#if (!isFirstCommand) Write("else "); #>if( command.CommandID.Guid.Equals( this.cmd<#= element[CanonicalName] #>GUID ) )
                {
					foreach (object selectedObject in this.CurrentSelection)
					{
<#
	string[] supportedTypes = element["SupportedCommandTypes"].Split(',');
	bool isFirstType = true;
	foreach (string supportedType in supportedTypes)
	{
		switch (supportedType)
		{
			case "Property":
#>
						<#if (!isFirstType) Write("else "); #>if (selectedObject is AttributeProperty || selectedObject is ElementProperty)
							canCommandRun &= true;
<#
					isFirstType = false;
				break;
			
			case "Diagram":
#>
						<#if (!isFirstType) Write("else"); #> if (selectedObject is Diagram)
							canCommandRun &= true;
<#
					isFirstType = false;
				break;
			
			default:
#>
					// FIXME: Unrecognized SupportedCommandTypes "<#= supportedType #>" encountered
<#
				break;
		}
	}
#>
						else
							canCommandRun = false;
					}
					
					CanCommandRun("cmd<#= element[CanonicalName] #>", ref canCommandRun);
                    command.Enabled = canCommandRun;
                    command.Visible = canCommandRun;
                    return;
                }
<#
	isFirstCommand = false;
}
#>
            }
        }
        
        // Partial method for dealing with special cases of command enabling. Implement
        // in a separate partial class if required.
        partial void CanCommandRun(string commandName, ref bool canCommandRun);

        /// <summary>
        /// Occurs when one of the custom menu items is clicked.
        /// </summary>
        /// <param name="sender">Sender of this event.</param>
        /// <param name="e">Event arguments.</param>
        internal void OnPopUpMenuClick( object sender, EventArgs e )
        {
            // Get the current menu command
            MenuCommand command = sender as MenuCommand;

            if( command != null )
            {
<#
foreach (Dictionary<string, string> element in commands)
{
	string commandId;
	if (!element.TryGetValue(CommandId, out commandId))			
	{
#>
                if(command.CommandID.Guid.Equals(this.cmd<#= element[CanonicalName] #>GUID))
                {
                    this.<#= element[CanonicalName] #>();
                }
<#
	}
	else
	{
#>
                if(command.CommandID.Guid.Equals(this.cmd<#= element[CanonicalName] #>GUID) && command.CommandID.ID == <#= commandId #>)
                {
                    this.<#= element[CanonicalName] #>();
                }
<#
	}
}
#>
            }
        }

        #endregion

		private DynamicStatusMenuCommand CreateCommand(EventHandler statusHandler, EventHandler invokeHandler, CommandID commandId)
        {
            return new DynamicStatusMenuCommand(statusHandler, invokeHandler, commandId);
        }
    }
}