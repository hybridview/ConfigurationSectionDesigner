<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" debug="true" hostspecific="true" 
#><#@ output extension=".config" 
#><#@ assembly name="System.Configuration.dll" 
#><#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" 
#><#@ assembly name="Microsoft.VisualStudio.Shell.Interop.11.0" 
#><#@ assembly name="EnvDTE" 
#><#@ assembly name="EnvDTE80" 
#><#@ assembly name="EnvDTE100" 
#><#@ import namespace="System.Collections.Generic" 
#><#@ import namespace="System.IO" 
#><#@ import namespace="Microsoft.VisualStudio.Shell.Interop" 
#><#@ import namespace="EnvDTE" 
#><#@ import namespace="EnvDTE80" 
#><#@ import namespace="EnvDTE100" 
#><#@ import namespace="System.Security.Cryptography" 
#><#@ import namespace="System.Reflection" 
#><#@ ConfigurationSectionDesigner processor="ConfigurationSectionDesignerDirectiveProcessor" requires="fileName='$inputFileName$'" 
#><# Prepare(); 
#><?xml version="1.0"?>
<!--
<auto-generated>
    This code was generated by a tool.

     Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
-->
<configuration>
	<configSections>
<#

// Find top-level sections and section groups
List<IConfigSectionElement> topLevel = new List<IConfigSectionElement>();
foreach (BaseConfigurationType element in this.ConfigurationSectionModel.ConfigurationElements)
{
    if (element.InheritanceModifier == InheritanceModifiers.Abstract) continue;
    
	IConfigSectionElement configSectionElement = element as IConfigSectionElement;
	if (configSectionElement != null)
	{
		ConfigurationSection configSection = configSectionElement as ConfigurationSection;
		ConfigurationSectionGroup configSectionGroup = configSectionElement as ConfigurationSectionGroup;
		
		if (configSection != null)
		{
			// Are we a top-level element?
			if (configSection.ReferringConfigurationSectionGroup == null)
				topLevel.Add(configSection);
		}
		else if (configSectionGroup != null)
		{
			// Are we a top-level element?
			if (configSectionGroup.ReferringConfigurationSectionGroup == null)
				topLevel.Add(configSectionGroup);
		}
	}
}

PushIndent("\t");
foreach (IConfigSectionElement configSectionElement in topLevel)
{
	WriteConfigSection(configSectionElement);
}
PopIndent();
#>
	</configSections>
<#

foreach (IConfigSectionElement configSectionElement in topLevel)
{
	WriteConfig(configSectionElement, true);
}
#>
</configuration>
<#+

private void WriteConfigSection(IConfigSectionElement configSectionElement)
{
	PushIndent("\t");
	
	ConfigurationSection configSection = configSectionElement as ConfigurationSection;
	ConfigurationSectionGroup configSectionGroup = configSectionElement as ConfigurationSectionGroup;
	
	if (configSection != null)
	{
		//WriteLine("<section name=\"{0}\" type=\"{1}{2}\"/>", new object[] { configSection.XmlSectionName, configSection.FullName, (!string.IsNullOrEmpty(this.ConfigurationSectionModel.AssemblyName)) ? ", " + this.ConfigurationSectionModel.AssemblyName : ""  } );
		string assemblyName = Project.Properties.Item("AssemblyName").Value as string;
		string assemblyVersion = Project.Properties.Item("AssemblyVersion").Value as string;
		
		bool sign = (bool)Project.Properties.Item("SignAssembly").Value;
		
		string fullPath = Project.Properties.Item("FullPath").Value as string;
		string keyFile = Project.Properties.Item("AssemblyOriginatorKeyFile").Value as string;
		keyFile = Path.Combine(fullPath, keyFile);
		
		string publicKeyToken = "null";
		if (sign && File.Exists(keyFile))
		{
			using (var keyPairFile = File.Open(keyFile, FileMode.Open, FileAccess.Read))
			{
				StrongNameKeyPair pair = new StrongNameKeyPair(keyPairFile);
				publicKeyToken = BitConverter.ToString(GetKeyTokenFromFullKey(pair.PublicKey)).Replace("-","").ToLower();
			}
		}
		
		WriteLine("<section name=\"{0}\" type=\"{1}, {2}, Version={3}, Culture=neutral, PublicKeyToken={4}\"/>", new object[] { configSection.XmlSectionName, configSection.FullName, assemblyName, assemblyVersion, publicKeyToken } );
	
	}
	else if (configSectionGroup != null)
	{
		WriteLine("<sectionGroup name=\"{0}\" type=\"{1}\">", new object[] { configSectionGroup.Name, typeof(System.Configuration.ConfigurationSectionGroup).AssemblyQualifiedName } );
		if( configSectionGroup.ConfigurationSectionGroupProperties.Count > 0 )
		{
			foreach( ConfigurationSectionGroupProperty configurationSectionGroupProperty in configSectionGroup.ConfigurationSectionGroupProperties )
			{
				WriteConfigSection(configurationSectionGroupProperty.ContainedConfigurationSectionGroup);
			}
		}
		if( configSectionGroup.ConfigurationSectionProperties.Count > 0 )
		{
			foreach( ConfigurationSectionProperty configurationSectionProperty in configSectionGroup.ConfigurationSectionProperties )
			{
				WriteConfigSection(configurationSectionProperty.ContainedConfigurationSection);
			}
		}
		WriteLine("</sectionGroup>");
	}
	
	PopIndent();
}

private void WriteConfig(IConfigSectionElement configSectionElement, bool isTopLevel)
{
	PushIndent("\t");
	
	ConfigurationSection configSection = configSectionElement as ConfigurationSection;
	ConfigurationSectionGroup configSectionGroup = configSectionElement as ConfigurationSectionGroup;
	
	if (configSection != null)
	{
		if (isTopLevel)
			WriteLine("<{0} xmlns=\"{1}\">", new object[] { configSection.XmlSectionName, this.ConfigurationSectionModel.XmlSchemaNamespace } );
		else
			WriteLine("<{0}>", new object[] { configSection.XmlSectionName, this.ConfigurationSectionModel.XmlSchemaNamespace } );
		PushIndent("\t");
		WriteLine("<!--");
		WriteLine("This is just a minimal sample configuration file that shows how to declare");
		WriteLine("the configuration sections.");
		WriteLine("");
		WriteLine("Because an XML Schema Definition (XSD) is generated for each configuration");
		WriteLine("section, it should be trivial to edit these files because you have");
		WriteLine("IntelliSense on the XML definition.");
		WriteLine("-->");
		PopIndent();
		WriteLine("</{0}>", new object[] { configSection.XmlSectionName } );
	}
	else if (configSectionGroup != null)
	{
		if (isTopLevel)
			WriteLine("<{0} xmlns=\"{1}\">", new object[] { configSectionGroup.Name, this.ConfigurationSectionModel.XmlSchemaNamespace } );
		else
			WriteLine("<{0}>", new object[] { configSectionGroup.Name } );
		if( configSectionGroup.ConfigurationSectionGroupProperties.Count > 0 )
		{
			foreach( ConfigurationSectionGroupProperty configurationSectionGroupProperty in configSectionGroup.ConfigurationSectionGroupProperties )
			{
				WriteConfig(configurationSectionGroupProperty.ContainedConfigurationSectionGroup, false);
			}
		}
		if( configSectionGroup.ConfigurationSectionProperties.Count > 0 )
		{
			foreach( ConfigurationSectionProperty configurationSectionProperty in configSectionGroup.ConfigurationSectionProperties )
			{
				WriteConfig(configurationSectionProperty.ContainedConfigurationSection, false);
			}
		}
		WriteLine("</{0}>", new object[] { configSectionGroup.Name } );
	}
	
	PopIndent();
}

static string ModelFileName = @"$inputFileName$";
static DTE Dte;
static Project Project;

void Prepare()
{
    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null)
	{
        Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
    }

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (Dte == null)
	{
        throw new Exception("The Configuration Section Designer templates can only execute through the Visual Studio host");
    }
	
    Project = Dte.Solution.FindProjectItem(ModelFileName).ContainingProject;

    if (Project == null)
	{
        Error("Could not find the VS Project containing the Configuration Section Designer file.");
        return;
	}
}

static byte[] GetKeyTokenFromFullKey(byte[] fullKey)
{
	SHA1CryptoServiceProvider csp = new SHA1CryptoServiceProvider();
	byte[] hash = csp.ComputeHash(fullKey);
	byte[] token = new byte[8];
	for (int i = 0; i < 8; i++ )
		token[i] = hash[hash.Length - (i+1)];

	return token;
}
#>